Goal: Update the existing RoiModal so the focus rectangle is draggable and resizable via 4 corner handles (TL/TR/BR/BL). Enforce min size and keep it within image bounds. On Save, store normalized 0..1 points (TL, TR, BR, BL) exactly as before via saveRoomScanRegion.

Tasks

Replace app/components/RoiModal.tsx with the code below (full file overwrite):

// app/components/RoiModal.tsx
import React, { useMemo, useRef, useState } from 'react';
import { Modal, View, Image, PanResponder, StyleSheet, Text, Pressable, LayoutChangeEvent } from 'react-native';

type Pt = { x: number; y: number };

function clamp(v: number, min: number, max: number) {
  'worklet';
  return Math.max(min, Math.min(max, v));
}

export default function RoiModal({
  visible,
  imageUrl,
  onCancel,
  onSave,
  label = 'Area 1',
}: {
  visible: boolean;
  imageUrl: string;
  onCancel: () => void;
  onSave: (points: Pt[], label: string) => void;
  label?: string;
}) {
  const [wrapW, setWrapW] = useState(0);
  const [wrapH, setWrapH] = useState(0);

  // Rect state in pixels (container coords)
  const rect = useRef({ x: 0, y: 0, w: 0, h: 0 });
  const [version, setVersion] = useState(0); // force re-render on drag/resize

  const MIN_W = Math.max(24, Math.round(wrapW * 0.15)); // ~15% width min
  const MIN_H = Math.max(24, Math.round(wrapH * 0.15)); // ~15% height min

  function centerInit(width: number, height: number) {
    const w = Math.round(width * 0.6);
    const h = Math.round(height * 0.4);
    const x = Math.round((width - w) / 2);
    const y = Math.round((height - h) / 2);
    rect.current = { x, y, w, h };
  }

  function onWrapLayout(e: LayoutChangeEvent) {
    const { width, height } = e.nativeEvent.layout;
    setWrapW(width);
    setWrapH(height);
    if (!rect.current.w || !rect.current.h) {
      centerInit(width, height);
      setVersion(v => v + 1);
    } else {
      // Clamp existing rect if container changed
      const r = rect.current;
      r.w = clamp(r.w, MIN_W, width);
      r.h = clamp(r.h, MIN_H, height);
      r.x = clamp(r.x, 0, Math.max(0, width - r.w));
      r.y = clamp(r.y, 0, Math.max(0, height - r.h));
      setVersion(v => v + 1);
    }
  }

  // Drag whole rect
  const dragRect = useMemo(
    () =>
      PanResponder.create({
        onStartShouldSetPanResponder: () => true,
        onMoveShouldSetPanResponder: () => true,
        onPanResponderMove: (_evt, g) => {
          const r = rect.current;
          const nx = clamp(r.x + g.dx, 0, Math.max(0, wrapW - r.w));
          const ny = clamp(r.y + g.dy, 0, Math.max(0, wrapH - r.h));
          rect.current = { ...r, x: nx, y: ny };
          setVersion(v => v + 1);
        },
        onPanResponderRelease: () => {},
      }),
    [wrapW, wrapH]
  );

  // Corner handle factories
  function makeHandlePan(which: 'tl'|'tr'|'br'|'bl') {
    return PanResponder.create({
      onStartShouldSetPanResponder: () => true,
      onMoveShouldSetPanResponder: () => true,
      onPanResponderMove: (_evt, g) => {
        const r = rect.current;
        let x = r.x, y = r.y, w = r.w, h = r.h;

        if (which === 'tl') {
          const nx = clamp(x + g.dx, 0, x + w - MIN_W);
          const ny = clamp(y + g.dy, 0, y + h - MIN_H);
          w = w + (x - nx);
          h = h + (y - ny);
          x = nx; y = ny;
        } else if (which === 'tr') {
          const nx = clamp(x, 0, wrapW - MIN_W);
          const ny = clamp(y + g.dy, 0, y + h - MIN_H);
          const right = clamp(x + w + g.dx, x + MIN_W, wrapW);
          w = right - x;
          h = h + (y - ny);
          y = ny;
        } else if (which === 'br') {
          const right = clamp(x + w + g.dx, x + MIN_W, wrapW);
          const bottom = clamp(y + h + g.dy, y + MIN_H, wrapH);
          w = right - x;
          h = bottom - y;
        } else if (which === 'bl') {
          const nx = clamp(x + g.dx, 0, x + w - MIN_W);
          const bottom = clamp(y + h + g.dy, y + MIN_H, wrapH);
          w = w + (x - nx);
          h = bottom - y;
          x = nx;
        }

        // Keep inside bounds
        x = clamp(x, 0, Math.max(0, wrapW - w));
        y = clamp(y, 0, Math.max(0, wrapH - h));
        w = clamp(w, MIN_W, wrapW - x);
        h = clamp(h, MIN_H, wrapH - y);

        rect.current = { x, y, w, h };
        setVersion(v => v + 1);
      },
      onPanResponderRelease: () => {},
    });
  }

  const panTL = useMemo(() => makeHandlePan('tl'), [wrapW, wrapH, MIN_W, MIN_H]);
  const panTR = useMemo(() => makeHandlePan('tr'), [wrapW, wrapH, MIN_W, MIN_H]);
  const panBR = useMemo(() => makeHandlePan('br'), [wrapW, wrapH, MIN_W, MIN_H]);
  const panBL = useMemo(() => makeHandlePan('bl'), [wrapW, wrapH, MIN_W, MIN_H]);

  function handleSave() {
    if (!wrapW || !wrapH) return;
    const { x, y, w, h } = rect.current;
    const pts: Pt[] = [
      { x: x / wrapW,       y: y / wrapH },         // TL
      { x: (x + w) / wrapW, y: y / wrapH },         // TR
      { x: (x + w) / wrapW, y: (y + h) / wrapH },   // BR
      { x: x / wrapW,       y: (y + h) / wrapH },   // BL
    ];
    onSave(pts, label);
  }

  const r = rect.current;

  return (
    <Modal visible={visible} animationType="slide" transparent>
      <View style={S.backdrop}>
        <View style={S.sheet}>
          <Text style={S.title}>Mark focus area</Text>
          <View style={S.imageWrap} onLayout={onWrapLayout}>
            {!!imageUrl && (
              <Image source={{ uri: imageUrl }} style={S.image} resizeMode="contain" />
            )}

            {/* Draggable rectangle */}
            <View
              {...dragRect.panHandlers}
              style={[
                S.rect,
                { width: r.w, height: r.h, transform: [{ translateX: r.x }, { translateY: r.y }] },
              ]}
            >
              <Text style={S.caption}>
                {Math.round((r.w / (wrapW || 1)) * 100)}% × {Math.round((r.h / (wrapH || 1)) * 100)}%
              </Text>

              {/* Corner handles */}
              <View {...panTL.panHandlers} style={[S.handle, S.tl]} />
              <View {...panTR.panHandlers} style={[S.handle, S.tr]} />
              <View {...panBR.panHandlers} style={[S.handle, S.br]} />
              <View {...panBL.panHandlers} style={[S.handle, S.bl]} />
            </View>
          </View>

          <View style={S.row}>
            <Pressable onPress={onCancel} accessibilityRole="button" style={[S.btn, S.ghost]}>
              <Text style={[S.btnText, S.ghostText]}>Cancel</Text>
            </Pressable>
            <Pressable onPress={handleSave} accessibilityRole="button" style={[S.btn, S.primary]}>
              <Text style={S.btnText}>Save Area</Text>
            </Pressable>
          </View>
        </View>
      </View>
    </Modal>
  );
}

const HANDLE = 22;

const S = StyleSheet.create({
  backdrop: { flex: 1, backgroundColor: 'rgba(0,0,0,0.5)', justifyContent: 'flex-end' },
  sheet: { backgroundColor: 'white', padding: 16, borderTopLeftRadius: 16, borderTopRightRadius: 16, gap: 12, maxHeight: '90%' },
  title: { fontSize: 18, fontWeight: '600' },
  imageWrap: { width: '100%', aspectRatio: 1, backgroundColor: '#f3f4f6', borderRadius: 12, overflow: 'hidden', position: 'relative' },
  image: { position: 'absolute', width: '100%', height: '100%' },
  rect: {
    position: 'absolute',
    borderWidth: 2,
    borderColor: 'rgba(99,102,241,0.95)',
    backgroundColor: 'rgba(99,102,241,0.18)',
    alignItems: 'center',
    justifyContent: 'center',
  },
  caption: {
    position: 'absolute',
    bottom: -26,
    backgroundColor: 'rgba(17,24,39,0.9)',
    color: 'white',
    paddingHorizontal: 6,
    paddingVertical: 2,
    borderRadius: 6,
    fontSize: 12,
  },
  handle: {
    position: 'absolute',
    width: HANDLE,
    height: HANDLE,
    backgroundColor: '#6d28d9',
    borderRadius: 6,
    borderWidth: 2,
    borderColor: 'white',
  },
  tl: { top: -HANDLE/2, left: -HANDLE/2 },
  tr: { top: -HANDLE/2, right: -HANDLE/2 },
  br: { bottom: -HANDLE/2, right: -HANDLE/2 },
  bl: { bottom: -HANDLE/2, left: -HANDLE/2 },
  row: { flexDirection: 'row', gap: 12, justifyContent: 'flex-end', marginTop: 4 },
  btn: { paddingHorizontal: 14, paddingVertical: 10, borderRadius: 10 },
  primary: { backgroundColor: '#6d28d9' },
  btnText: { color: 'white', fontWeight: '600' },
  ghost: { backgroundColor: 'transparent', borderWidth: 1, borderColor: '#e5e7eb' },
  ghostText: { color: '#111827' },
});


No other files changed. Keep your saveRoomScanRegion import/usage in NewProject.tsx exactly as you wired in Step 5a.

Acceptance Criteria

The focus rectangle is draggable and resizable with 4 corner handles.

The rectangle cannot shrink below ~15% of image width/height and cannot leave the image bounds.

The size badge updates live (percent of image).

Tapping Save Area inserts into public.room_scan_regions with:

kind = 'focus_area'

normalized = true

points = [TL, TR, BR, BL] normalized 0..1

Modal closes after success; toast “Area saved” (as you already had).